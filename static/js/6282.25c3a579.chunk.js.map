{"version":3,"file":"static/js/6282.25c3a579.chunk.js","mappings":"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","sources":["../../../node_modules/.pnpm/viem@2.13.10_bufferutil@4.0.8_typescript@5.6.3_utf-8-validate@5.0.10_zod@3.23.8/node_modules/viem/errors/ccip.ts","../../../node_modules/.pnpm/viem@2.13.10_bufferutil@4.0.8_typescript@5.6.3_utf-8-validate@5.0.10_zod@3.23.8/node_modules/viem/utils/ccip.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  override name = 'OffchainLookupError'\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  override name = 'OffchainLookupResponseMalformedError'\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n      },\n    )\n  }\n}\n\n/** @internal */\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  override name = 'OffchainLookupSenderMismatchError'\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n      },\n    )\n  }\n}\n","import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  type OffchainLookupErrorType as OffchainLookupErrorType_,\n  OffchainLookupResponseMalformedError,\n  type OffchainLookupResponseMalformedErrorType,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n} from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = OffchainLookupErrorType_ | ErrorType\n\nexport async function offchainLookup<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  const { ccipRead } = client\n  const ccipRequest_ =\n    ccipRead && typeof ccipRead?.request === 'function'\n      ? ccipRead.request\n      : ccipRequest\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = await ccipRequest_({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipRequestParameters = {\n  data: Hex\n  sender: Address\n  urls: readonly string[]\n}\n\nexport type CcipRequestReturnType = Hex\n\nexport type CcipRequestErrorType =\n  | HttpRequestErrorType\n  | OffchainLookupResponseMalformedErrorType\n  | ErrorType\n\nexport async function ccipRequest({\n  data,\n  sender,\n  urls,\n}: CcipRequestParameters): Promise<CcipRequestReturnType> {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],"names":["OffchainLookupError","callbackSelector","cause","data","extraData","sender","urls","url","OffchainLookupResponseMalformedError","result","stringify","OffchainLookupSenderMismatchError","to","offchainLookupSignature","offchainLookupAbiItem","offchainLookup","client","blockNumber","blockTag","args","decodeErrorResult","callData","ccipRead","ccipRequest_","ccipRequest","isAddressEqual","data_","call","concat","encodeAbiParameters","err","error","i","method","body","response","isHex"],"sourceRoot":""}